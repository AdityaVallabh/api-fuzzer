# Execution Plan #

## Summary
This is a living doc on our current execution strategy.

## Plan on architecture
The client side needs to be lean and clean, with no dependencies. The client will be done in golang. Because of the lack of ML and NLP libraries, the client side will only execute well-structured plans, with some tolerence on human edits, but will not do machine learning.

The server side will collect the swagger.json, does NLP analysis on it, and generate the @meqa tags needed for client to execute. 

The testplan.yml can either be generated by the client or the server.
* Client
    * we can have something fully functioning without the server piece. With just people editing the swagger.json.
    * Not sharing test plans between client and server means we don't have a potential breaking point where the two may be out of sync in versions.
    * Our customers can have better performance and flexibility when generating test plans.
    * Can golang client automatically update itself?
* Server
    * We will have more flexibility in the kind of technology we can leverage. For instance, we can leverage spacy.io during plan generation.
    * We can more quickly roll out enhancements - when we employ some new algorithms on the server side to generate better plans, all our clients can immediately benefit. We can tell our customers that if they try generate a new plan, the diff will tell them what new tests are added, and they can decide whether to use the new plan or just the old one.
    * The above plan generation on server will be good for SaaS business.

Decision
* Test plan generation is done on the server side in python.
* 